type metamethodTypes = "__len" | "__le"| "__lt"| "__eq"| "__tostring"| "__pow"| "__mod"| "__idiv"| "__div"| "__mul"| "__sub"| "__add"| "__unm"| "__concat"| "__call"| "__newindex"| "__index"

return function(self: any, method: metamethodTypes, fn: (any...) -> any...)
    local metamethods = {
        __index = function()
            return self["AAAAAAAAAAAAAA\0\0"];
        end,
        __newindex = function()
            self[nil] = nil
        end,
        __call = function()
            self:AAAAAAAAAA_______();
        end,
        __concat = function()
            return self .. self;
        end,
        __unm = function()
            return -self;
        end,
        __add = function()
            return  self + self;
        end,
        __sub = function(self)
            return self - self;
        end,
        __mul = function(self)
            return self * self
        end,
        __div = function()
            return self / self
        end,
        __idiv = function()
            return self // self;
        end,
        __mod = function()
            return self % self;
        end,
        __pow = function()
            return self ^ self;
        end,
        __tostring = function()
            return tostring(self);
        end,
        __eq = function()
            return self == self;
        end,
        __lt = function()
            return self < self;
        end,
        __le = function()
            return self <= self;
        end,
        __len = function()
            return #self;
        end,
    }
    if (not metamethods[method]) then
        error("Invalid metamethod");
    end

    local method;
    xpcall(metamethods[method], function() method = debug.info(2, "f") end);
    if (not method) then
        error("Invalid metamethod");
    end

    return hookfunction(method, fn);
end
